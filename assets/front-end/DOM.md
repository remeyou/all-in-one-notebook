# DOM

## cookie、localStorage 和 sessionStorage 的区别

三者都储存在浏览器，而且同源（同协议、同域名、同端口）

cookie 会在 http 请求中携带，会在服务器和浏览器间传递，所以 cookie 会有大小限制，不能超过 4k，而且存在在设定的 path 下，故 cookie 的安全性不高。在 Server 生成可设置有效时间，在 Browser 生成默认关闭浏览器清除。原生使用麻烦，需要封装 API。（设置 http-only 携带 token 可以防止 XSS 攻击，提升安全性）

sessionStorage 和 localStorage 只会存在本地，大小要比 cookie 大，其中 sessionStorage 是仅在当前的会话窗口有效，不是所有窗口都可以共享数据的。其它两个是个浏览器都可以数据共享。原生使用方便，可直接作为 window 对象的属性使用。

## 事件委托

事件触发机制：冒泡、捕获

事件委托：利用冒泡的特点，将本应该注册到子元素身上的事件，注册到父级元素，在点击子元素的时候，通过冒泡的方式将点击事件传递给父级，在父级进行监听。

优点：

1. 减少 DOM 操作（性能优化关键点）
2. 减少函数定义，优化内存空间
3. 动态添加的子元素也能监听到事件

## 事件循环（event-loop）

JS 语言最大的特点就是单线程，同一时间只能处理一件事。

单线程优点：能够防止 DOM 操作的时候出现混乱，一边在修改、一边在删除这种场景不允许出现的。因此所有的任务都要排队才能执行。

单线程缺点：每个任务都要排队，很多任务耗时比较多，我们如果都要等待，用户体验非常差。

```js
console.log("chengdu"); // IO操作 性能比较低
$.ajax(); // 3s 异步 XMLHttpRequest
alert(123); // 阻塞代码，会阻塞下文的js执行
```

### 浏览器特点

浏览器是一个多进程的应用程序。浏览器可以同时执行很多任务。

浏览器内核：最核心的部分。组成包括

- **JS 引擎**：例如 V8 引擎，作用是解析 js 代码
- **GUI 引擎**：渲染引擎，主要负责页面内容的渲染。包括 HTML 解析器、CSS 解析器等等内容
- **定时器执行引擎**：只要你的代码有定时器任务，用定时器引擎来执行
- **异步请求引擎**：只要发现代码中出现异步，浏览器马上使用异步以前来处理请求，不影响其他代码执行
- **事件触发引擎**：当你绑定了事件过后，我们将任务交给事件处理引擎来执行

#### 浏览器线程特点

1. 主线程：代码从上到下的执行时被主线程控制的。整个代码只有一个主线程
2. 执行栈：栈结构，先进后出,默认放在栈底的时全局上下文对象，里面存放的全局变量。根据函数的顺序要决定如何入栈。（先入后出，后入先出）

### 事件循环过程

1. 主线程先执行代码。分析全局变量、函数等等内容。
2. 先将全局变量放入到全局上下文对象中，入栈放入栈底
3. 发现有函数调用，创建函数上下文对象，里面存放函数内部的变量。函数内部代码
4. 函数内部如果执行 JavaScript 库里面的 API，有些同步 api、有些异步的 api dom 操作都同步操作，请求都是异步。
5. 发现时异步任务，将异步任务放在**事件队列**（内存专门开辟的空间，浏览器找这里面异步任务，异步请求来执行）
6. 主线程执行完毕，这个检测队列里面任务是否完成，等待完成。一旦完成，主线调用队列里面的任务获取结果/这个过程在持续的执行，除非所有的异步任务都执行完毕。
7. 任务队列里面的每一个任务要被主线程调用，浏览器会给每个任务绑定一个**事件**，主线程执行完毕后，通过事件的方式来调用异步任务结果。
8. 主线程结束。

### 异步任务分类

宏任务：script 里面包含的代码 默认也是一个宏任务，setTimeout、setInterval、IO

微任务：promise.then\Object.observe\nextTick

一般微任务先执行，宏任务后执行
